---
layout: simple
title: CVE-2022-0995 Review - Part 1
---

## **OverView**

해당 취약점은 리눅스의 `watch_queue` 에 특정 `filter`를 적용할 때 발생하는 취약점이다. 

## **What is watch queue?**

`watch_queue`는 [General notification mechanism](https://docs.kernel.org/core-api/watch_queue.html#overview)에서 사용하는 개념이다. 

General notification mechanism 은 리눅스 시스템 내에 이벤트 및 변경사항을 모니터링 하기 위해 만들어진 매커니즘이다. 특정 시스템 이벤트에 실시간으로 반응하는 어플리케이션이 해당 매커니즘을 이용한다. 

대표적으로 해당 매커니즘을 이용하는 어플리케이션으로는 [watchdog](https://linux.die.net/man/8/watchdog) 이 있겠다. 

General notification mechanism 은 pipe 의 형태로 구현된다. pipe 내부의 버퍼는 커널에서 생성된 메시지를 보관한다. 그리고 해당 메시지는 `read()` 를 통해 읽는 것이 가능하다. 

pipe 의 소유자는 커널에게 어떤 소스를 볼 것인지 요청 할 수 있다. 그럼으로써 요청한 소스만 파이프에 메시지를 보내게 된다.

또한 pipe 의 소유자는 `filter`를 이용하여 특정 소스나 이벤트에 대한 메시지를 필터링 할 수 있다. 

![General notification mechanism](/assets/img/study/cve_2022_0995/general_notification_mechanism.png)

커널로 부터 메시지를 받는 pipe는 다음과 같이 생성할 수 있다. 

```c
pipe2(fds, O_IOC_WATCH_QUEUE);
```

다음으로 해당 파이프에 ioctl로 watch 할 메시지 설정을 할 수 있다. 아래 코드는 256바이트의 메시지를 수용할 수 있게 하는 설정을 하는 코드이다. 

```c
ioctl(fds[1], IOC_WATCH_QUEUE_SET_SIZE, 256);
```

파이프에 특정 필터를 설정하는 코드는 다음과 같다. 

```c
ioctl(fds[0], IOC_WATCH_QUEUE_SET_FILTER, filter) 
```

## **Vulnerability**

이제 직접 General notification mechanism 에서 filter를 추가할 때 어떻게 취약점이 유발되는지 코드를 통해 살펴보자 

내가 분석한 코드는 5.13.18 버전의 리눅스 커널이다. 

먼저 `pipe2`를 통해 파이프를 생성하면 어떻게 `ioctl`이 이루어지는 지 살펴보자.

+ fs/pipe.c

```c
static int do_pipe2(int __user *fildes, int flags)
{
	struct file *files[2];
	int fd[2];
	int error;

	error = __do_pipe_flags(fd, files, flags);
	if (!error) {
		if (unlikely(copy_to_user(fildes, fd, sizeof(fd)))) {
			fput(files[0]);
			fput(files[1]);
			put_unused_fd(fd[0]);
			put_unused_fd(fd[1]);
			error = -EFAULT;
		} else {
			fd_install(fd[0], files[0]);
			fd_install(fd[1], files[1]);
		}
	}
	return error;
}
```

`pipe2` syscall 을 호출하면 `do_pipe2()` 함수가 호출되고, 해당 함수는 `__do_pipe_flags()` 함수를 호출한다. 

+ fs/pipe.c

```c
static int __do_pipe_flags(int *fd, struct file **files, int flags)
{
	int error;
	int fdw, fdr;

	if (flags & ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT | O_NOTIFICATION_PIPE))
		return -EINVAL;

	error = create_pipe_files(files, flags);
	if (error)
		return error;

	error = get_unused_fd_flags(flags);
	if (error < 0)
		goto err_read_pipe;
	fdr = error;

	error = get_unused_fd_flags(flags);
	if (error < 0)
		goto err_fdr;
	fdw = error;

	audit_fd_pair(fdr, fdw);
	fd[0] = fdr;
	fd[1] = fdw;
	return 0;

 err_fdr:
	put_unused_fd(fdr);
 err_read_pipe:
	fput(files[0]);
	fput(files[1]);
	return error;
}

/* ... */

int create_pipe_files(struct file **res, int flags)
{
	struct inode *inode = get_pipe_inode();
	struct file *f;
	int error;

	if (!inode)
		return -ENFILE;

	if (flags & O_NOTIFICATION_PIPE) {
		error = watch_queue_init(inode->i_pipe);
		if (error) {
			free_pipe_info(inode->i_pipe);
			iput(inode);
			return error;
		}
	}

	f = alloc_file_pseudo(inode, pipe_mnt, "",
				O_WRONLY | (flags & (O_NONBLOCK | O_DIRECT)),
				&pipefifo_fops);
	if (IS_ERR(f)) {
		free_pipe_info(inode->i_pipe);
		iput(inode);
		return PTR_ERR(f);
	}

	f->private_data = inode->i_pipe;

	res[0] = alloc_file_clone(f, O_RDONLY | (flags & O_NONBLOCK),
				  &pipefifo_fops);
	if (IS_ERR(res[0])) {
		put_pipe_info(inode, inode->i_pipe);
		fput(f);
		return PTR_ERR(res[0]);
	}
	res[0]->private_data = inode->i_pipe;
	res[1] = f;
	stream_open(inode, res[0]);
	stream_open(inode, res[1]);
	return 0;
}

/* ... */

int create_pipe_files(struct file **res, int flags)
{
	struct inode *inode = get_pipe_inode();
	struct file *f;
	int error;

	if (!inode)
		return -ENFILE;

	if (flags & O_NOTIFICATION_PIPE) {
		error = watch_queue_init(inode->i_pipe);
		if (error) {
			free_pipe_info(inode->i_pipe);
			iput(inode);
			return error;
		}
	}

	f = alloc_file_pseudo(inode, pipe_mnt, "",
				O_WRONLY | (flags & (O_NONBLOCK | O_DIRECT)),
				&pipefifo_fops);
	if (IS_ERR(f)) {
		free_pipe_info(inode->i_pipe);
		iput(inode);
		return PTR_ERR(f);
	}

	f->private_data = inode->i_pipe;

	res[0] = alloc_file_clone(f, O_RDONLY | (flags & O_NONBLOCK),
				  &pipefifo_fops);
	if (IS_ERR(res[0])) {
		put_pipe_info(inode, inode->i_pipe);
		fput(f);
		return PTR_ERR(res[0]);
	}
	res[0]->private_data = inode->i_pipe;
	res[1] = f;
	stream_open(inode, res[0]);
	stream_open(inode, res[1]);
	return 0;
}
```

`__do_pipe_flags()` 함수는 `create_pipe_files()` 함수를 호출하고, `create_pipe_files()` 함수는 `get_pipe_inode()` 함수를 호출한다. `get_pipe_inode()` 함수는 해당 inode 의 file_operations 구조체를 `pipefifo_fops` 로 할당한다. 

+ fs/pipe.c

```c
const struct file_operations pipefifo_fops = {
	.open		= fifo_open,
	.llseek		= no_llseek,
	.read_iter	= pipe_read,
	.write_iter	= pipe_write,
	.poll		= pipe_poll,
	.unlocked_ioctl	= pipe_ioctl,
	.release	= pipe_release,
	.fasync		= pipe_fasync,
	.splice_write	= iter_file_splice_write,
};
```

`pipefifo_fops` 의 `unlocked_ioctl` 필드는 `pipe_ioctl()` 함수인 것을 알 수 있다. 

즉, `pipe2()` 함수를 통하여 생성된 fd 에 ioctl을 요청하면, `pipe_ioctl()` 함수가 해당 요청을 핸들링 하는 것을 알 수 있다. 

## **References**

+ <https://bsauce.github.io/2022/04/15/CVE-2022-0995/#1-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86>
+ <https://docs.kernel.org/core-api/watch_queue.html#overview>