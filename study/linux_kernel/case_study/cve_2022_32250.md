---
layout: simple
title: cve-2022-32250 Review
---

## **Intro**

이 글은 [Theori에서 작성해 주신 글을 이해하면서 작성해간 노트이다.](https://blog.theori.io/linux-kernel-exploit-cve-2022-32250-with-mqueue-a8468f32aab5)

이 취약점은 netfilter 에서 발생하는 UAF(Use-After-Free) 취약점이며, 해당 취약점을 이용해 권한 상승을 할 수 있다. 

같이 본 코드는 linux-5.15.27 버전이다.

취약점을 찾기 앞서, 포스트에서는 `nftables` 에 대한 간략한 설명만 해주고 넘어간다.

## **Netfilter Structures**

> nftables have tables, chains, rules, and expressions to store and process instructions. tables contain several chains and are linked to protocols such as IP and IP6. chains include several rules and the types of network traffic information to be processed. rules contain several expressions, and the information received by chains is evaluated as rules inside chains. expressions evaluate whether the input satisfies a set of conditions.

이 부분을 좀더 자세히 알아보자

`nftable` 이란 뭘까? `nftable` 은 netfilter에서 각 네트워크 프로토콜에 대한 핸들러를 지정하는 컨테이너이다. 

filter 핸들러는 각 netfilter 후크 위치에 설치되고, 해당 후크에서 핸들러가 실행될 때마다 `nftable`의 처리가 시작된다. 

리눅스 커널 내에서는 `struct nft_table` 로 정의된다. 

+ include/net/netfilter/nf_table.c

```c
struct nft_table {
	struct list_head		list;
	struct rhltable			chains_ht;
	struct list_head		chains;
	struct list_head		sets;
	struct list_head		objects;
	struct list_head		flowtables;
	u64				hgenerator;
	u64				handle;
	u32				use;
	u16				family:6,
					flags:8,
					genmask:2;
	u32				nlpid;
	char				*name;
	u16				udlen;
	u8				*udata;
};
```

`nftable` 은 일련의 `chain` 들을 가지고 있다. `chain` 에는 특정 트래픽에 관련되어 어떠한 처리를 할 것인지에 대한 정보를 담고 있다. 

앞서 특정 트래픽에 관련되어 어떤 행동을 가질지 결정하는 정보들이 `rule` 이다. 즉, `chain`은 여러 `rule` 의 집합이다. 

리눅스 커널 내에서는 `struct nft_chain` 으로 정의된다.

+ include/net/netfilter/nf_table.c

```c
struct nft_chain {
	struct nft_rule			*__rcu *rules_gen_0;
	struct nft_rule			*__rcu *rules_gen_1;
	struct list_head		rules;
	struct list_head		list;
	struct rhlist_head		rhlhead;
	struct nft_table		*table;
	u64				handle;
	u32				use;
	u8				flags:5,
					bound:1,
					genmask:2;
	char				*name;
	u16				udlen;
	u8				*udata;

	/* Only used during control plane commit phase: */
	struct nft_rule			**rules_next;
};
```

소스롤 보면 `nft_rule` 및 `rules` 가 리스트 형식으로 정의되어 있는 것을 알 수 있다. 

`rule` 은 커널 내에서 `struct nft_rule`로 정의된다. 

+ include/net/netfilter/nf_table.c

```c
struct nft_rule {
	struct list_head		list;
	u64				handle:42,
					genmask:2,
					dlen:12,
					udata:1;
	unsigned char			data[]
		__attribute__((aligned(__alignof__(struct nft_expr))));
};
```

`rule`은 특정 패킷에 대한 지정자인 표현식을 가지고 있다. 그러한 설명식이 `expression` 이다. 

`expression` 은 차례대로 반복되고 실행되서 실제 처리 작업을 진행한다. 

즉, 특정 패킷이 들어오면 `nftable`에 있는 여러 `chain`들이 순서에 따라 처리되고, `chain`은 가지고 있는 `rule`들에 대한 처리를 시작하며, `rule`은 자신이 가지고 있는 `expression`에 지정되어있는 행동을 한다. 

![nftable](/assets/img/study/cve_2022_32250/nftable.png)

그럼 정확히 `expression` 은 어떤 표현에 대한 것을 어떻게 처리할까

`expression`은 커널 내에서 `struct nft_expr`로 정의된다. 

+ include/net/netfilter/nf_table.c

```c
struct nft_expr {
	const struct nft_expr_ops	*ops;
	unsigned char			data[]
		__attribute__((aligned(__alignof__(u64))));
};
```

## **Vulnerability**

해당 취약점은 nf_tables_api.c 의 `nft_expr_init()` 함수에서 시작한다.

+ net/netfilter/nf_tables_api.c

```c
static struct nft_expr *nft_expr_init(const struct nft_ctx *ctx,
				      const struct nlattr *nla)
{
	struct nft_expr_info expr_info;
	struct nft_expr *expr;
	struct module *owner;
	int err;

	err = nf_tables_expr_parse(ctx, nla, &expr_info);
	if (err < 0)
		goto err1;

	err = -ENOMEM;
	expr = kzalloc(expr_info.ops->size, GFP_KERNEL);
	if (expr == NULL)
		goto err2;

	err = nf_tables_newexpr(ctx, &expr_info, expr);
	if (err < 0)
		goto err3;

	return expr;
err3:
	kfree(expr);
err2:
	owner = expr_info.ops->type->owner;
	if (expr_info.ops->type->release_ops)
		expr_info.ops->type->release_ops(expr_info.ops);

	module_put(owner);
err1:
	return ERR_PTR(err);
}
```

`nft_expr_init()` 함수는 `nf_tables_expr_parse()` 함수를 호출해 `expr_info`를 초기화 한 뒤, `kzalloc()` 함수를 이용해 `expr` 이라는 구조체를 할당한다. 

그 후 `nf_tables_newexpr()` 함수에 `expr_info` 를 인자로 주어 `expr` 구조체를 초기화 한다. 

`expr` 의 구조체인 `nft_expr`는 다음과 같다. 

+ include/net/netfilter/nf_tables.h

```c
struct nft_expr {
	const struct nft_expr_ops	*ops;
	unsigned char			data[]
		__attribute__((aligned(__alignof__(u64))));
};
```

`ops` 는 netfilter의 expression의 처리를 담당하는 함수의 포인터이다. 

data는 각 expression 에 맞는 구조체가 들어간다. 

우리가 볼 expression 인 `nft_lookup` 과 `nft_set_binding`의 구조체는 다음과 같이 선언된다. 

+ net/netfilter/nft_lookup.c

```c
struct nft_lookup {
	struct nft_set			*set;
	u8				sreg;
	u8				dreg;
	bool				invert;
	struct nft_set_binding		binding;
};

```

+ net/netfilter/nf_tables.h

```c
struct nft_set_binding {
	struct list_head		list;
	const struct nft_chain		*chain;
	u32				flags;
};
```






## **References**
+ <https://blog.theori.io/linux-kernel-exploit-cve-2022-32250-with-mqueue-a8468f32aab5>
+ <https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.15.27.tar.gz>
+ <https://https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/>
